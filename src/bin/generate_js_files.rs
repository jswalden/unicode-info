extern crate unicode_info;

use std::fmt;
use std::result::Result;
use unicode_info::case_folding;
use unicode_info::code_point_table;

enum Error {
    #[allow(unused)]
    Unknown,
}

impl fmt::Debug for Error {
    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        match self {
            Error::Unknown => {
                write!(fmt, "unknown error")
            }
        }
    }
}

const WARNING_MESSAGE: &str = r#"/* Generated by make_unicode.py DO NOT MODIFY */
"#;

fn unicode_version(version: &str) -> String {
    format!(
        r#"Unicode version {version}
"#,
        version = version
    )
}

const PUBLIC_DOMAIN: &str = r#"
/*
 * Any copyright is dedicated to the Public Domain.
 * http://creativecommons.org/licenses/publicdomain/
 */
"#;

fn generate_unicode_ignorecase_js(
    all_codes_with_equivalents: &Vec<case_folding::CodeAndEquivalents>,
    table: &code_point_table::CodePointTable,
) -> Result<(), Error> {
    let mut str = String::new();

    str += WARNING_MESSAGE;
    str += unicode_version("v13.0.0").as_str();
    str += PUBLIC_DOMAIN;

    str += r#"
var BUGNUMBER = 1135377;
var summary = "Implement RegExp unicode flag -- ignoreCase flag.";

print(BUGNUMBER + ": " + summary);

function test(code, equivs) {
    var codeRe = new RegExp(String.fromCodePoint(code) + "+", "iu");
    var ans = String.fromCodePoint(code) + equivs.map(c => String.fromCodePoint(c)).join("");
    assertEqArray(codeRe.exec("<" + ans + ">"), [ans]);
    codeRe = new RegExp("[" + String.fromCodePoint(code) + "]+", "iu");
    assertEqArray(codeRe.exec("<" + ans + ">"), [ans]);
}

"#;

    fn to_hex(code: u32) -> String {
        format!("{:#04X}", code)
    }

    for (code, equivs) in all_codes_with_equivalents.iter() {
        let equivalents = equivs
            .iter()
            .map(|code| to_hex(*code))
            .collect::<Vec<String>>()
            .join(", ");
        let descs = equivs
            .iter()
            .map(|c| table.name(*c))
            .collect::<Vec<String>>()
            .join(", ");
        str += format!(
            r#"test({code}, [{equivalents}]); // {descs}
"#,
            code = to_hex(*code),
            equivalents = equivalents,
            descs = descs
        )
        .as_str();
    }

    Ok(())
}

fn main() -> Result<(), Error> {
    let table = code_point_table::generate_code_point_table();
    let case_folding = case_folding::process_case_folding();

    generate_unicode_ignorecase_js(&case_folding.all_codes_with_equivalents, &table)?;

    Ok(())
}
