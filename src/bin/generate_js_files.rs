extern crate unicode_info;

use std::fs::File;
use std::io;
use std::io::Write;
use unicode_info::case_folding;
use unicode_info::code_point_table;
use unicode_info::derived_core_properties;

const PRODUCTION: bool = false;

fn write_file(path: &str, s: String) -> io::Result<usize> {
    if PRODUCTION {
        let mut f = File::create(path)?;
        f.write(s.as_bytes())
    } else {
        Ok(0)
    }
}

const WARNING_MESSAGE: &str = "/* Generated by make_unicode.py DO NOT MODIFY */\n";

fn unicode_version_comment(version: &str) -> String {
    format!("/* Unicode version: {version} */\n", version = version)
}

const PUBLIC_DOMAIN: &str = r#"
/*
 * Any copyright is dedicated to the Public Domain.
 * http://creativecommons.org/licenses/publicdomain/
 */
"#;

fn generate_regexp_character_class_escape_js() -> io::Result<()> {
    Ok(())
}

fn generate_string_code_point_upper_lower_mapping_js() -> io::Result<()> {
    Ok(())
}

fn generate_string_upper_lower_mapping_js() -> io::Result<()> {
    Ok(())
}

fn generate_string_space_trim_js() -> io::Result<()> {
    Ok(())
}
fn generate_unicode_ignorecase_js(
    version: &str,
    all_codes_with_equivalents: &Vec<case_folding::CodeAndEquivalents>,
    table: &code_point_table::CodePointTable,
) -> io::Result<()> {
    fn to_hex(code: &u32) -> String {
        format!("{:#04X}", code)
    }

    let mut str: String = String::new();
    str += WARNING_MESSAGE;
    str += unicode_version_comment(version).as_str();
    str += PUBLIC_DOMAIN;

    str += r#"
var BUGNUMBER = 1135377;
var summary = "Implement RegExp unicode flag -- ignoreCase flag.";

print(BUGNUMBER + ": " + summary);

function test(code, equivs) {
    var codeRe = new RegExp(String.fromCodePoint(code) + "+", "iu");
    var ans = String.fromCodePoint(code) + equivs.map(c => String.fromCodePoint(c)).join("");
    assertEqArray(codeRe.exec("<" + ans + ">"), [ans]);
    codeRe = new RegExp("[" + String.fromCodePoint(code) + "]+", "iu");
    assertEqArray(codeRe.exec("<" + ans + ">"), [ans]);
}
"#;

    for (code, equivs) in all_codes_with_equivalents.iter() {
        let equivalents = equivs
            .iter()
            .map(to_hex)
            .collect::<Vec<String>>()
            .join(", ");
        let names = equivs
            .iter()
            .map(|c| table.name(*c))
            .collect::<Vec<String>>()
            .join(", ");
        str += format!(
            "test({code}, [{equivalents}]); // {names}\n",
            code = to_hex(code),
            equivalents = equivalents,
            names = names
        )
        .as_str();
    }

    write_file("../tests/non262/RegExp/unicode-ignoreCase.js", str)?;

    Ok(())
}

fn main() -> io::Result<()> {
    {
        let base_path = std::env::current_dir().expect("couldn't get current working directory");
        if !base_path.ends_with("js/src/util") {
            panic!(
                "{} must be run from js/src/util",
                match std::env::args().next() {
                    Some(arg) => arg,
                    None => "generate_js_files".to_string(),
                }
            );
        }
    }

    // Every input file contains an embedded Unicode version somewhere...except
    // `UnicodeData.txt`.  Alas.
    let version: &'static str = derived_core_properties::unicode_version();

    let table = code_point_table::generate_code_point_table();

    let case_folding = case_folding::process_case_folding();

    generate_regexp_character_class_escape_js()?;
    generate_string_space_trim_js()?;
    generate_string_code_point_upper_lower_mapping_js()?;
    generate_string_upper_lower_mapping_js()?;
    generate_unicode_ignorecase_js(&version, &case_folding.all_codes_with_equivalents, &table)?;

    Ok(())
}
