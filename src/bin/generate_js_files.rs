extern crate unicode_info;

use std::fs::File;
use std::io;
use std::io::Write;
use std::path::PathBuf;
use unicode_info::bmp;
use unicode_info::case_folding;
use unicode_info::code_point_table;
use unicode_info::constants::MAX_BMP;
use unicode_info::derived_core_properties;
use unicode_info::non_bmp;
use unicode_info::special_casing;

const PRODUCTION: bool = false;

fn write_file(path: &str, s: String) -> io::Result<usize> {
    assert!(
        path.starts_with("js/src"),
        "must write to repo-relative path"
    );
    let mut p = PathBuf::new();
    if PRODUCTION {
        p.push("../../.."); // escape out of js/src/util
    } else {
        p.push("/tmp/");
    }
    p.push(path);
    File::create(p)?.write(s.as_bytes())
}

const WARNING_MESSAGE: &str = "/* Generated by make_unicode.py DO NOT MODIFY */\n";

fn unicode_version_comment(version: &str) -> String {
    format!("/* Unicode version: {version} */\n", version = version)
}

const PUBLIC_DOMAIN: &str = r#"
/*
 * Any copyright is dedicated to the Public Domain.
 * http://creativecommons.org/licenses/publicdomain/
 */
"#;

fn generate_regexp_character_class_escape_js() -> io::Result<()> {
    Ok(())
}

fn generate_string_code_point_upper_lower_mapping_js(
    version: &str,
    table: &code_point_table::CodePointTable,
    non_bmp: &non_bmp::NonBMPInfo,
) -> io::Result<()> {
    let non_bmp::NonBMPInfo {
        uppercase_map,
        lowercase_map,
        ..
    } = non_bmp;

    let mut str = String::new();

    str += WARNING_MESSAGE;
    str += unicode_version_comment(version).as_str();
    str += PUBLIC_DOMAIN;

    for (code, mapping) in uppercase_map.iter() {
        let (code, mapping) = (*code, *mapping);
        str += format!(r#"assertEq(String.fromCodePoint({code:#06X}).toUpperCase().codePointAt(0), {upper:#06X}); // {name}, {upper_name}
"#, code = code, upper = mapping, name = table.name(code), upper_name = table.name(mapping)
).as_str();
    }

    for (code, mapping) in lowercase_map.iter() {
        let (code, mapping) = (*code, *mapping);
        str += format!(r#"assertEq(String.fromCodePoint({code:#06X}).toLowerCase().codePointAt(0), {lower:#06X}); // {name}, {lower_name}
"#, code = code, lower = mapping, name = table.name(code), lower_name = table.name(mapping)
).as_str();
    }

    str += r#"
if (typeof reportCompare === "function")
    reportCompare(true, true);
"#;

    write_file(
        "js/src/tests/non262/String/string-code-pointupper-lower-mapping.js",
        str,
    )?;

    Ok(())
}

fn generate_string_upper_lower_mapping_js(
    version: &str,
    cpt: &code_point_table::CodePointTable,
    special_casing: &special_casing::SpecialCasingData,
) -> io::Result<()> {
    let special_casing::SpecialCasingData {
        unconditional_toupper,
        unconditional_tolower,
        ..
    } = special_casing;

    fn unicode_esc(code: u32) -> String {
        format!("\\u{:04X}", code)
    }

    fn to_mapped_string(codes: Vec<u32>, func: &dyn Fn(u32) -> String) -> String {
        codes.into_iter().map(func).collect()
    }

    let mut str = String::new();

    str += WARNING_MESSAGE;
    str += unicode_version_comment(version).as_str();
    str += PUBLIC_DOMAIN;

    str += r#"var mapping = [
"#;

    for code in 0..=MAX_BMP {
        match cpt.get(code) {
            Some(code_point) => {
                let upper = code_point.uppercase();
                let upper = match unconditional_toupper.get(&code_point.code) {
                    Some(code) => code.clone(),
                    None => vec![upper],
                };

                let lower = code_point.lowercase();
                let lower = match unconditional_tolower.get(&code_point.code) {
                    Some(code) => code.clone(),
                    None => vec![lower],
                };

                str += format!(
                    r#"  ["{upper}", "{lower}"], /* {name} */
"#,
                    upper = to_mapped_string(upper, &unicode_esc),
                    lower = to_mapped_string(lower, &unicode_esc),
                    name = cpt.name(code),
                )
                .as_str();
            }
            None => {
                str += format!(
                    r#"  ["{code}", "{code}"],
"#,
                    code = unicode_esc(code)
                )
                .as_str();
            }
        }
    }
    str += r#"];
"#;

    str += r#"
assertEq(mapping.length, 0x10000);
for (var i = 0; i <= 0xffff; i++) {
    var char = String.fromCharCode(i);
    var info = mapping[i];

    assertEq(char.toUpperCase(), info[0]);
    assertEq(char.toLowerCase(), info[1]);
}

if (typeof reportCompare === "function")
    reportCompare(true, true);
"#;

    write_file(
        "js/src/tests/non262/String/string-upper-lower-mapping.js",
        str,
    )?;

    Ok(())
}

fn generate_string_space_trim_js() -> io::Result<()> {
    Ok(())
}
fn generate_unicode_ignorecase_js(
    version: &str,
    all_codes_with_equivalents: &Vec<case_folding::CodeWithEquivalents>,
    table: &code_point_table::CodePointTable,
) -> io::Result<()> {
    fn to_hex(code: &u32) -> String {
        // Note: 6 to encompass "0x" plus four remaining digits.
        format!("{:#06x}", code)
    }

    let mut str: String = String::new();
    str += WARNING_MESSAGE;
    str += unicode_version_comment(version).as_str();
    str += PUBLIC_DOMAIN;

    str += r#"
var BUGNUMBER = 1135377;
var summary = "Implement RegExp unicode flag -- ignoreCase flag.";

print(BUGNUMBER + ": " + summary);

function test(code, ...equivs) {
  var codeRe = new RegExp(String.fromCodePoint(code) + "+", "iu");
  var ans = String.fromCodePoint(code) + equivs.map(c => String.fromCodePoint(c)).join("");
  assertEqArray(codeRe.exec("<" + ans + ">"), [ans]);
  codeRe = new RegExp("[" + String.fromCodePoint(code) + "]+", "iu");
  assertEqArray(codeRe.exec("<" + ans + ">"), [ans]);
}
"#;

    for (code, equivs) in all_codes_with_equivalents.iter() {
        let equivalents = equivs
            .iter()
            .map(to_hex)
            .collect::<Vec<String>>()
            .join(", ");
        let names = {
            let mut v = vec![*code];
            v.extend(equivs);
            v
        }
        .iter()
        .map(|c| table.name(*c))
        .collect::<Vec<String>>()
        .join(", ");
        str += format!(
            "test({code}, {equivalents}); // {names}\n",
            code = to_hex(code),
            equivalents = equivalents,
            names = names
        )
        .as_str();
    }

    str += r#"
if (typeof reportCompare === "function")
    reportCompare(true, true);
"#;

    write_file("js/src/tests/non262/RegExp/unicode-ignoreCase.js", str)?;

    Ok(())
}

fn main() -> io::Result<()> {
    {
        let base_path = std::env::current_dir().expect("couldn't get current working directory");
        if !base_path.ends_with("js/src/util") {
            panic!(
                "{} must be run from js/src/util",
                match std::env::args().next() {
                    Some(arg) => arg,
                    None => "generate_js_files".to_string(),
                }
            );
        }
    }

    // Every input file contains an embedded Unicode version somewhere...except
    // `UnicodeData.txt`.  Alas.
    let version: &'static str = derived_core_properties::unicode_version();

    let table = code_point_table::generate_code_point_table();
    let dcp = derived_core_properties::process_derived_core_properties();
    let bmp = bmp::generate_bmp_info(&table, &dcp);
    let non_bmp = non_bmp::generate_non_bmp_info(&table);

    let case_folding = case_folding::process_case_folding();

    let special_casing = special_casing::process_special_casing(&bmp);

    generate_regexp_character_class_escape_js()?;
    generate_string_space_trim_js()?;
    generate_string_code_point_upper_lower_mapping_js(&version, &table, &non_bmp)?;
    generate_string_upper_lower_mapping_js(&version, &table, &special_casing)?;
    generate_unicode_ignorecase_js(&version, &case_folding.all_codes_with_equivalents, &table)?;

    Ok(())
}
